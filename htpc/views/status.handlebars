<h3>{{title}}</h3>
<div id="vueApp">
  <div class="downloads">
    <div v-if="downloads.length > 0" v-for="download in sortedDownloads" class="item" v-bind:class="download.status">
      <header>${download.path}/${download.file_name}</header>
      <div class="transferInfo">
        <progress-bar v-bind:download="download"></progress-bar>
      </div>
      <div class=itemInfo>
        <div class="source">
          from: ${download.source_root}
        </div>
        <div class="dest">
          to: ${download.dest_root}
        </div>
        ${download.date_added}
        ${download.uid}
      </div>
    </div>
  </div>
</div>

<script>
var jsonAPI = '/status/ui';

Vue.component('progress-bar', {
  template : '<div class="transferInfo"><div class="progressBar"><div class="bar" v-bind:style="{width : progress }"><div class="progressPct">${progress}</div></div></div><div class="transferProgress">${downloadedUnits} / ${sizeUnits} - ${speedUnits}/s</div>',
  props : ['download'],
  //for consistency with the main vue app
  delimiters : ['${', '}'],
  computed :  {
    progress : function (){
      var pctDone = this.download.downloaded / this.download.size * 100;
      return pctDone.toFixed(2) + "%";
    },
    //I'm sorry for this, but scope is weird in Vue components, so I couldn't figure out how to do a utility function to handle the byte unit conversion. Also, I'm still learning Vue. Someday, this will be very embarassing.
    downloadedUnits : function(){
      var bytes = this.download.downloaded;
      if(bytes == 0) return '0 bytes';
      var k = 1000,
	dm = 1; 
	sizes = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    },
    sizeUnits: function(){
      var bytes = this.download.size;
      if(bytes == 0) return '0 bytes';
      var k = 1000,
	dm = 1;
	sizes = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    },
    speedUnits: function(){
      var bytes = this.download.download_rate;
      if(bytes == 0) return '0 bytes';
      var k = 1000,
	dm = 1; 
	sizes = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
  }
});


var vueApp = new Vue({
  delimiters: ['${', '}'],
  el: '#vueApp', 
  data: { 
    downloads : [] 
  },
  //On Vue app creation:
  created : function(){
    var self = this;
    function updateData(){
      $.getJSON(jsonAPI).then(function(response){
        self.stats = response.stats;
        self.downloads = response.downloads;
      }, function(error){
        console.log(error);  
      });
    }
    setInterval(updateData, 1000);
  },
  computed: {
    sortedDownloads : function(){
      var downloading = this.downloads.filter(function(item){
        return item.status == "downloading";
      });
      var queued = this.downloads.filter(function(item){
        return item.status == "queued";
      });
      var completed = this.downloads.filter(function(item){
        return item.status == "completed";
      });

      function timeLeft(item){
        var bytesToGo = item.size - item.downloaded;
        var secondsToGo = bytesToGo / item.download_rate;
        return secondsToGo;
      }

      function sortByCompletion(itemA, itemB){
        return timeLeft(itemA) - timeLeft(itemB);
      }

      return downloading.sort(sortByCompletion).concat(queued, completed);
    }
  }
});

</script>
